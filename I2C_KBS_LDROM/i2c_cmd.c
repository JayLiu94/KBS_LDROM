/*-----------------------------------------------------------------------------------------------------------
 *  Nuvoton Technology Corporation Confidential
 *
 *  Copyright (c) 2018-2022 by Nuvoton Technology Corporation
 *  All rights reserved
 *
 *<<<----------------------------------------------------------------------------------------------------->>>
 * Filename: task_kbscan.c
 *      The keyboard matrix scan task handlers
 *
 * Project:
 *            Nuvoton Embedded Controller Firmware
 *---------------------------------------------------------------------------------------------------------*/
#include "prj_config.h"

static uint8_t kbc_led_control[2];
static uint8_t kbc_gpio_control[2];
static uint8_t kbc_system_setting[2];
static uint8_t kbc_gpio_status[2];


#define I2C_MSG_QUE_WAIT_TIME       100
#define I2C_KBS_INT_PULSE           5

static bool send_kbs_int;

void t2b_send_kbs_int(void)
{
    GPIO_PIN_DATA(PORT_E, PIN_4) = 0;
    //TIMER_Delay(TIMER1, I2C_KBS_INT_PULSE);
    GPIO_PIN_DATA(PORT_E, PIN_4) = 1;
}

void T2B_I2C_Init(void)
{
    send_kbs_int = false;

    I2C_StopCallback_Config(T2B_I2C_Stop_Hanelder);
    I2C_WriteCallback_Config(T2B_I2C_Write_Hanelder);
    I2C_WriteReadCallback_Config(T2B_I2C_Write_Read_Handler);
    I2C_ReadCallback_Config(T2B_I2C_Read_Handler);
}

void T2B_I2C_Stop_Hanelder(void)
{
    if(send_kbs_int == true)
    {
        send_kbs_int = false;
        t2b_send_kbs_int();
    }
}

void T2B_I2C_Write_Hanelder(uint16_t I2cRxCnt, uint8_t *I2cRxBuf)
{
    switch(I2cRxBuf[0])
    {
        // Handle command from Tablet that indicate that events
        // can be generated by the Base
        case 10:
            // KBC_i2c_int_out = high
            break;
    }
}

uint16_t T2B_I2C_Write_Read_Handler(uint16_t I2cRxCnt, uint8_t *I2cRxBuf, uint8_t *I2cTxBuf)
{
    uint16_t SlvTxCnt;

    switch(I2cRxBuf[0])
    {
        // read Product ID
        case 0x10:
            memcpy(&I2cTxBuf[0], (void *) &product_id, 4);
            SlvTxCnt = 4;
            break;

        // read Company ID
        case 0x11:
            memcpy(&I2cTxBuf[0], (void *) &company_id, 4);
            SlvTxCnt = 4;
            break;

        // read LDROM Firmware Size
        case 0x12:
            memcpy(&I2cTxBuf[0], (void *) &ld_fw_size, 4);
            SlvTxCnt = 4;
            break;

        // read LDROM Firmware Version
        case 0x13:
            memcpy(&I2cTxBuf[0], (void *) &ld_fw_version, 4);
            SlvTxCnt = 4;
            break;

        // read APROM Firmware Size
        case 0x14:
            memcpy(&I2cTxBuf[0], (void *) &ap_fw_size, 4);
            SlvTxCnt = 4;
            break;

        // read APROM Firmware Version
        case 0x15:
            memcpy(&I2cTxBuf[0], (void *) &ap_fw_version, 4);
            SlvTxCnt = 4;
            break;

        // read APROM Firmware Checksum
        case 0x16:
            memcpy(&I2cTxBuf[0], (void *) &ap_fw_checksum, 4);
            SlvTxCnt = 4;
            break;

        // read APROM Data Checksum
        case 0x17:
            memcpy(&I2cTxBuf[0], (void *) &ap_rom_checksum, 4);
            SlvTxCnt = 4;
            break;

        // enable APROM ISP 
        case 0x20:
            Enable_APROM_ISP_Function();
            break;

        case 0x21:
            Disable_APROM_ISP_Function();
            break;

        case 0x22:
            set_service_flags(SERVICE_FLAG_APROM_IDENTIFY);
            I2cTxBuf[0] = 0x00;
            break;

        //case 0x23:
        //    memcpy((uint8_t *) &Aprom_isp_addr, (void *) &I2cRxBuf[1], 4);
        //    memcpy((uint8_t *) &Aprom_isp_size, (void *) &I2cRxBuf[5], 4);
        //    set_service_flags(SERVICE_FLAG_APROM_ERASE);
        //    I2cTxBuf[0] = 0x00;
        //    break;

        //case 0x24:
        //    memcpy((uint8_t *) &Aprom_isp_addr, (void *) &I2cRxBuf[1], 4);
        //    memcpy((uint8_t *) &Aprom_isp_size, (void *) &I2cRxBuf[5], 4);
        //    memcpy((uint8_t *) &Aprom_isp_data_buf, (void *) &I2cRxBuf[9], 64);
        //    set_service_flags(SERVICE_FLAG_APROM_WRITE);
        //    I2cTxBuf[0] = 0x00;
        //    break;

        default:
        	SlvTxCnt = 0;
        	break;
    }

    return(SlvTxCnt);
}

uint16_t T2B_I2C_Read_Handler(uint8_t *I2cTxBuf)
{
    return(0);
}







